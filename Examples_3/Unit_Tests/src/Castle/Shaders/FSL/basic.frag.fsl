/*
 * Copyright (c) 2017-2024 The Forge Interactive Inc.
 *
 * This file is part of The-Forge
 * (see https://github.com/ConfettiFX/The-Forge).
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
*/

// Shader for simple shading with a point light

#include "resourcesCastle.h.fsl"

float4 cubeMapping( float3 v, float3 n )
{
	// Point3 normalWorld = scp.VectorToNoScale(normalVector, REF_WORLD);

	// Point3 viewWorld = scp.VectorToNoScale(viewVector, REF_WORLD);

	// float nx = normalWorld.x;
	// float ny = normalWorld.y;
	// float nz = normalWorld.z;

	// float vx = viewWorld.x;
	// float vy = viewWorld.y;
	// float vz = viewWorld.z;



	// float rx = vx - 2 * nx * (nx * vx + ny * vy + nz * vz);
	// float ry = vy - 2 * ny * (nx * vx + ny * vy + nz * vz);
	// float rz = vz - 2 * nz * (nx * vx + ny * vy + nz * vz);

	float3 r =  v - 2 * n * dot(n, v);


	////////////////////////////////////////////////////////////////////////////////
	// float u, v;
	// float uOff, vOff;

	float2 uv;
	float2 uvOff;

	float4 cubeColor;

	if (r.x > r.y && r.x >= -r.y && r.x > r.z && r.x >= -r.z) {
		//rx=1

		uv = float2(r.z / r.x, r.y / r.x);
		uvOff = float2(2., 1.);

		cubeColor = SampleTex2D(RightText, Get(uSampler0), (-uv + float2(1., 1.)) / 2.);

		// v = r.z / r.x;
		// u = r.y / r.x;
		// uOff = 2.;
		// vOff = 1.;
	}

	if (-r.x >= r.y && -r.x > -r.y && -r.x >= r.z && -r.x > -r.z) {

		//rx=- 1
		uv = float2(-(r.z / r.x), (r.y / r.x));
		uvOff = float2( 0., 1.);

		cubeColor = SampleTex2D(LeftText, Get(uSampler0), (uv + float2(1., 1.)) / 2.);

		// v = -(r.z / r.x);
		// u = (r.y / r.x);
		// uOff = 0.;
		// vOff = 1.;
	}

	if (r.y >= r.x && r.y > -r.x && r.y >= r.z && r.y > -r.z) {
		//ry=1
		uv = float2(r.x / r.y, r.z / r.y);
		uvOff = float2( 3., 1.);

		cubeColor = SampleTex2D(TopText, Get(uSampler0), (uv + float2(1., 1.)) / 2.);

		// u = -r.x / r.y;
		// v = r.z / r.y;
		// uOff = 3.;
		// vOff = 1.;
	}

	if (-r.y > r.x && -r.y >= -r.x && -r.y > r.z && -r.y >= -r.z) {

		//ry=- 1
		uv = float2(-(r.x / r.y), (r.z / r.y));
		uvOff = float2( 1., 1.);

		cubeColor = SampleTex2D(BotText, Get(uSampler0), (uv + float2(1., 1.)) / 2.);

		// u = -(r.x / r.y);
		// v = -(r.z / r.y);
		// uOff = 1.;
		// vOff = 1.;
	}

	if (r.z >= r.x && r.z > -r.x && r.z > r.y && r.z >= -r.y) {

		//rz=1
		uv = float2(r.x / r.z, - r.y / r.z);
		uvOff = float2(1., 2.);

		cubeColor = SampleTex2D(BackText, Get(uSampler0), (uv + float2(1., 1.)) / 2.);

		// u = r.x / r.z;
		// v = r.y / r.z;
		// uOff = 1.;
		// vOff = 2.;
	}

	if (-r.z > r.x && -r.z >= -r.x && -r.z >= r.y && -r.z > -r.y) {

		//rz=- 1
		uv = float2((r.x / r.z), (r.y / r.z));
		uvOff = float2( 1., 0.);

		cubeColor = SampleTex2D(FrontText, Get(uSampler0), (uv + float2(1., 1.)) / 2.);

		// u = -(r.x / r.z);
		// v = (r.y / r.z);
		// uOff = 1.;
		// vOff = 0.;
	}

	// Point3 oUVW;
	// float toClamp = 0.0;

	// toClamp = (float)(u + 1) / 2;
	// oUVW.x = (1. / 4.) * ((toClamp > 0.99 ? 0.99 : (toClamp < 0.0 ? 0.0 : toClamp)) + uOff);

	// toClamp = (float)(v + 1) / 2;
	// oUVW.y = (1. / 3.) * ((toClamp > 0.99 ? 0.99 : (toClamp < 0.0 ? 0.0 : toClamp)) + vOff);
	// oUVW.z = 0.0f;

	// scp.SetUVW(oUVW);
	// retval = mpCubeMap->EvalColor(scp);

	return cubeColor;
}

STRUCT(VSOutput)
{
	DATA(float4, Position, SV_Position);
    DATA(float3, lightPosition, none);
    DATA(float3, Normal, NORMAL);
	DATA(float4, Color,    COLOR);
	DATA(float3, TexCoord, TEXCOORD0);
    DATA(float3, WorldPosition, TEXCOORD1);
    DATA(float3, binormal, TEXCOORD2);
    DATA(float3, tangent, TEXCOORD3);
};

float4 PS_MAIN( VSOutput In )
{
    INIT_MAIN;

    float3 lightPos = Get(lightPosition);

    float3 Normal = normalize(In.Normal);
    float3 binormal = normalize(In.binormal);
    float3 tangent = normalize(In.tangent);

    //float3 Normal = In.Normal;
    //float3 binormal = normalize(cross(In.Normal, In.tangent));
    //float3 tangent = normalize(cross(In.Normal, binormal));

    float4 sampledColor = float4(0.0, 0.0, 0.0, 1.0);
    float4 sampledBump = float4(0.0, 0.0, 0.0, 1.0);

    int texIndex = int(round(In.TexCoord.z));

    if(texIndex == 0)
    {
        sampledColor = SampleTex2D(Interior, Get(uSampler0), In.TexCoord.xy);
        sampledBump = SampleTex2D(InteriorBump, Get(uSampler0), In.TexCoord.xy);
        //sampledBump = SampleTex2D(RightText, Get(uSampler0), In.TexCoord.xy);
    }
    else if(texIndex == 1)
    {
        sampledColor = SampleTex2D(Fountain, Get(uSampler0), In.TexCoord.xy);
        sampledBump = SampleTex2D(FountainBump, Get(uSampler0), In.TexCoord.xy);
    }
    else if(texIndex == 2)
    {
        sampledColor = SampleTex2D(Towers, Get(uSampler0), In.TexCoord.xy);
        sampledBump = float4(0.0, 0.0, 0.0, 1.0);
    }
    else if(texIndex == 3)
    {
        sampledColor = SampleTex2D(Exterior, Get(uSampler0), In.TexCoord.xy);
        sampledBump = SampleTex2D(ExteriorBump, Get(uSampler0), In.TexCoord.xy);
    }

    float3 bumpedNormal = normalize(-(2.0 * sampledBump.x - 1.0) *  binormal - (2.0 * sampledBump.y - 1.0) *   tangent +   sampledBump.z  * Normal);

    // float3 bumpedNormal = Normal;

    float ambientLightIntesity = 0.4;

    //// diffuse reflection

    float3 LightVectorWorldSpace = normalize(Get(lightPosition) - In.WorldPosition);

    float diffuseIntensity = 0.7;

    float diffuselightIntensity = diffuseIntensity * saturate(dot(LightVectorWorldSpace, bumpedNormal));

    //// specular reflection

    float shininess = 50.0;

    float3 viewerWorldSpace = normalize(Get(viewerPosition) - In.WorldPosition);

    float3 R = 2*(dot(LightVectorWorldSpace,bumpedNormal)) * bumpedNormal - LightVectorWorldSpace ;

    float S = max(0.0, dot(R,viewerWorldSpace));

    float specularIntensity = 1.0;

    float specularLightIntensity = saturate(specularIntensity * pow(S, shininess));

    //float specularIntensity = saturate(dot(bumpedNormal, viewerWorldSpace));

    ////

    //float4 sampledColor = SampleTex2D(colorTex, Get(uSampler0), In.TexCoord.xy);

	//// Cube Mapping

	float4 cubeColor = cubeMapping( -viewerWorldSpace, bumpedNormal);

    //// Phong light model

    float4 lightFinal = float4(0.0, 0.0, 0.0, 1.0);

    lightFinal += (0.15 * float4(0.95, 0.95, 1.0, 1.0) + 0.85 * cubeColor ) * ambientLightIntesity;

    lightFinal += (0.15 * float4(0.95, 0.95, 1.0, 1.0) + 0.85 * cubeColor ) * diffuselightIntensity;

    lightFinal += float4(1.0, 1.0, 1.0, 1.0) * specularLightIntensity;

    
	RETURN(saturate(lightFinal));


    //RETURN(float4( (float3(1.0, 1.0, 1.0) + tangent ) /2.0, 1.0));
}
